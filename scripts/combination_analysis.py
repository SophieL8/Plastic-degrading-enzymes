# -*- coding: utf-8 -*-
"""Combination Analysis

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/17zrzp3tkYFP8z6jDpgUkZnPXy22hpece

# Combination Analysis
"""

import pandas as pd

# User-defined correlation method
correlation_method = "pearson"  # Change to "spearman" if needed

# Determine file prefix based on correlation method
prefix = "p_" if correlation_method == "pearson" else "s_"

# Step 1: Read enzyme names from the significant enzymes file
enzyme_names = []
with open(f'{prefix}sig_enzymes.tsv', 'r') as file:
    # Skip the header if necessary
    next(file)  # If there's a header, use this line to skip it
    for line in file:
        data = line.strip().split('\t')  # Assuming tab-delimited file
        enzyme = data[0]  # Assuming enzyme ID is in the first column
        enzyme_names.append(enzyme)

# Step 2: Read the enzyme abundance file and filter rows based on the enzyme names
release_df = pd.read_csv("enzyme_abundance.tsv", sep='\t')

# Create a filtered DataFrame containing only the rows with enzyme names present in the enzyme_names list
filtered_df = release_df[release_df['ko'].isin(enzyme_names)]

# Step 3: Calculate mean and standard deviation for each enzyme and store them in a dictionary
output_data = []

# Calculate mean and standard deviation for each row and store the results
for enzyme in enzyme_names:
    enzyme_rows = filtered_df[filtered_df['ko'] == enzyme]  # Filter rows for each enzyme
    means = enzyme_rows.iloc[:, 1:].mean(axis=1)  # Mean across the abundance columns
    std_devs = enzyme_rows.iloc[:, 1:].std(axis=1)  # Standard deviation across the abundance columns
    for mean, std_dev in zip(means, std_devs):
        output_data.append([enzyme, mean, std_dev])

# Step 4: Create a DataFrame for the mean and standard deviation and write it to a .tsv file
output_df = pd.DataFrame(output_data, columns=["Enzyme", "Mean", "Standard Deviation"])
output_df.to_csv(f"{prefix}mean_sd.tsv", sep='\t', index=False)

print(f"Mean and SD saved to {prefix}mean_sd.tsv")

# Step 5: Normalize the abundance data based on the calculated mean and standard deviation
mean_sd_values = {enzyme: {'mean': mean, 'std_dev': std_dev} for enzyme, mean, std_dev in zip(output_df['Enzyme'], output_df['Mean'], output_df['Standard Deviation'])}

# Step 6: Normalize the abundance data
normalized_data = []

for idx, row in filtered_df.iterrows():
    enzyme = row['ko']  # Enzyme ID
    if enzyme in mean_sd_values:
        mean = mean_sd_values[enzyme]['mean']
        std_dev = mean_sd_values[enzyme]['std_dev']

        # Normalize the abundance values (columns other than 'ko')
        normalized_row = [enzyme]  # Start with the enzyme ID
        for value in row[1:]:  # Skip the 'ko' column and normalize each abundance value
            normalized_value = (value - mean) / std_dev if std_dev != 0 else 0
            normalized_row.append(normalized_value)

        normalized_data.append(normalized_row)

# Step 7: Create a DataFrame for the normalized data and save it to a new file
normalized_df = pd.DataFrame(normalized_data, columns=filtered_df.columns)
normalized_df.to_csv(f"{prefix}normalized_abundance.tsv", sep='\t', index=False)

print(f"Normalized data saved to '{prefix}normalized_abundance.tsv'")

# Step 8: Sort rows based on the number of positive values (excluding the enzyme ID)
def count_positive(row):
    return sum(1 for value in row[1:] if float(value) > 0)

# List to store data rows
data_rows = []
with open(f'{prefix}normalized_abundance.tsv', 'r') as sorted_file:
    # Read the header (first row)
    header = sorted_file.readline().strip().split('\t')

    # Read and store the data rows
    for line in sorted_file:
        data_rows.append(line.strip().split('\t'))

# Sort data rows based on the number of positive values (excluding the enzyme ID)
sorted_rows = sorted(data_rows, key=count_positive, reverse=True)

# Step 9: Write sorted data to a new file
with open(f'{prefix}sorted_normalized.tsv', 'w') as output_file:
    # Write the header (first row)
    output_file.write('\t'.join(header) + '\n')

    # Write the sorted rows
    for row in sorted_rows:
        output_file.write('\t'.join(row) + '\n')

print(f"Sorted data based on the number of positive values written to '{prefix}sorted_normalized.tsv'")

# Step 10: Finding enzymes that have at least 10 positive values in their row
n = 10

with open(f'{prefix}sorted_normalized.tsv', 'r') as input_file, open(f'{prefix}single.tsv', 'w') as output_file:
    # Copy the first row to the output file
    first_row = input_file.readline()
    output_file.write(first_row)

    # Iterate through the remaining rows
    for line in input_file:
        values = line.strip().split('\t')

        # Count the number of positive values in the row (excluding the first column)
        count_positives = sum(float(value) > 0 for value in values[1:])

        # If the row has at least 'n' positive values, copy the entire row to the output file
        if count_positives >= n:
            output_file.write(line)

print(f"Filtered data with at least {n} positive values written to '{prefix}single.tsv'")

from scipy.stats import binom, mannwhitneyu, pearsonr, spearmanr
from itertools import combinations
import numpy as np
import pandas as pd

def calculate_binomial_distribution(k, n, p):
    return binom.pmf(k, n, p)

def extract_values(sample_name, pollution_data):
    for row in pollution_data:
        if row[0] == sample_name:
            return float(row[1])
    raise ValueError(f"Sample '{sample_name}' not found in pollution data.")

def calculate_correlation(x_values, y_values, method="pearson"):
    """Calculate Pearson or Spearman correlation coefficient."""
    if method == "pearson":
        correlation_coefficient, _ = pearsonr(x_values, y_values)
    elif method == "spearman":
        correlation_coefficient, _ = spearmanr(x_values, y_values)
    else:
        raise ValueError("Method must be either 'pearson' or 'spearman'")
    return correlation_coefficient

def process_combinations(combination_size, input_file, enzyme_percentages, sample_names, lines, n, correlation_method):
    # Determine file prefix based on correlation method
    prefix = "p_" if correlation_method == "pearson" else "s_"

    output_file_name = f'{prefix}combo{combination_size}.tsv'
    y_file_name = f'{prefix}Wilcoxon_y-values{combination_size}.tsv'
    samples_file_name = f'{prefix}Wilcoxon_y-samples{combination_size}.tsv'

    with open(output_file_name, 'w') as output_file, \
         open(y_file_name, 'w') as y_file, \
         open(samples_file_name, 'w') as samples_file:

        output_file.write('\t'.join([f'Enzyme{i+1}' for i in range(combination_size)] + ['Count Percentage', 'Matches', 'Binomial Distribution', 'p_value']) + '\n')
        y_file.write('\t'.join([f'Enzyme {"-".join([f"Enzyme{i+1}" for i in range(combination_size)])}', 'Values']) + '\n')

        for combo in combinations(range(len(lines)), combination_size):
            count_matches = 0
            positive_values = []

            for m in range(1, len(sample_names) + 1):
                values = [float(lines[idx].strip().split('\t')[m]) for idx in combo]
                if all(value > 0 for value in values):
                    count_matches += 1
                    positive_values.append(', '.join(map(str, values)))

            if count_matches >= n:
                samples = [lines[idx].strip().split('\t')[0] for idx in combo]
                percentages = [enzyme_percentages.get(sample, 0) for sample in samples]
                fraction = 1
                for p in percentages:
                    fraction *= p
                distribution = calculate_binomial_distribution(count_matches, 41, fraction)
                p_value = sum(calculate_binomial_distribution(k, 41, fraction) for k in range(count_matches, 42))

                if p_value < 0.01:
                    output_file.write('\t'.join(samples + [str(fraction), str(count_matches), str(distribution), str(p_value)]) + '\n')
                    combo_name = '-'.join(samples)
                    values_str = ', '.join(positive_values)
                    y_file.write(f'{combo_name}\t{values_str}\n')
                    for idx, value in enumerate(positive_values):
                        sample_name = sample_names[idx]
                        values_str = values_str.replace(value, sample_name)
                    samples_file.write(f'{combo_name}\t{values_str}\n')

def main():
    n = 10
    correlation_method = "pearson"  # Change to "pearson" or "spearman"

    # Determine file prefix based on correlation method
    prefix = "p_" if correlation_method == "pearson" else "s_"

    # Read enzyme percentages
    with open(f'{prefix}sorted_normalized.tsv', 'r') as enzyme_file:
        enzyme_names = enzyme_file.readline().strip().split('\t')[1:]
        enzyme_percentages = {}
        for line in enzyme_file:
            values = line.strip().split('\t')
            enzyme_name = values[0]
            positive_values = sum(1 for value in values[1:] if float(value) > 0)
            enzyme_percentages[enzyme_name] = positive_values / 243

    # Process input file
    with open(f'{prefix}single.tsv', 'r') as input_file:
        sample_names = input_file.readline().strip().split('\t')[1:]
        lines = input_file.readlines()

    # Process combinations of size 2, 3, and 4
    for combination_size in [2, 3, 4]:
        process_combinations(combination_size, input_file, enzyme_percentages, sample_names, lines, n, correlation_method)

    # Process y-values and x-values for combinations of size 2, 3, and 4
    for combination_size in [2, 3, 4]:
        y_file_name = f'{prefix}Wilcoxon_y-values{combination_size}.tsv'
        x_output_file_name = f'{prefix}Wilcoxon_x-values{combination_size}.tsv'

        with open(y_file_name, 'r') as y_file, \
             open(f'{prefix}single.tsv', 'r') as sample_file, \
             open(x_output_file_name, 'w') as x_output_file:

            y_values = {}
            next(y_file)
            for line in y_file:
                parts = line.strip().split('\t')
                combo_name = parts[0]
                values_str = parts[1]
                y_values[combo_name] = [float(value) for value in values_str.split(', ')]

            header = sample_file.readline().strip().split('\t')[1:]
            data = [line.strip().split('\t') for line in sample_file]

            x_output_file.write('\t'.join([f'Enzyme {"-".join([f"Enzyme{i+1}" for i in range(combination_size)])}', 'Sample Name', 'Enzyme Name', 'Values']) + '\n')

            for combo_name, y_positive_values in y_values.items():
                sample_names_combo = combo_name.split('-')
                for sample_name in sample_names_combo:
                    sample_row = next(row for row in data if row[0] == sample_name)
                    sample_positive_values = [float(value) for value in sample_row[1:] if float(value) > 0]
                    unique_values = set(sample_positive_values) - set(y_positive_values)

                    if unique_values:
                        for value in unique_values:
                            enzyme_name = header[sample_row[1:].index(str(value)) - 1]
                            x_output_file.write(f'{combo_name}\t{enzyme_name}\t{sample_name}\t{value}\n')

    # Perform Mann-Whitney U test for combinations of size 2, 3, and 4
    for combination_size in [2, 3, 4]:
        y_file_name = f'{prefix}Wilcoxon_y-samples{combination_size}.tsv'
        x_file_name = f'{prefix}Wilcoxon_x-values{combination_size}.tsv'
        mann_u_file_name = f'{prefix}MannU{combination_size}.tsv'

        with open('pollution_abundance.tsv', 'r') as pollution_file, \
             open(y_file_name, 'r') as y_file, \
             open(x_file_name, 'r') as x_file, \
             open(mann_u_file_name, 'w') as mann_u_file:

            next(pollution_file)
            pollution_data = [line.strip().split('\t') for line in pollution_file]

            y_values = {}
            for line in y_file:
                parts = line.strip().split('\t')
                combo_name = parts[0]
                values_str = parts[1]
                sample_values = []
                for sample_name in values_str.split(', '):
                    try:
                        value = extract_values(sample_name, pollution_data)
                        sample_values.append(value)
                    except ValueError as e:
                        print(f"Warning: {e}. Skipping this sample.")
                        continue
                y_values[combo_name] = sample_values

            x_values = {}
            next(x_file)
            for line in x_file:
                parts = line.strip().split('\t')
                combo_name = parts[0]
                sample_name = parts[1]
                enzyme_name = parts[2]
                try:
                    value = extract_values(sample_name, pollution_data)
                    key = f'{combo_name} {enzyme_name}'
                    if key in x_values:
                        x_values[key].append(value)
                    else:
                        x_values[key] = [value]
                except ValueError as e:
                    print(f"Warning: {e}. Skipping this sample.")
                    continue

            mann_u_file.write('\t'.join([f'Enzyme {"-".join([f"Enzyme{i+1}" for i in range(combination_size)])}', 'Enzyme Name', 'Mann U']) + '\n')
            for key, x_sample_values in x_values.items():
                combo_name, enzyme_name_x = key.split()
                y_sample_values = y_values.get(combo_name, [])
                if len(x_sample_values) >= 2 and len(y_sample_values) >= 2:
                    stat, p_value = mannwhitneyu(x_sample_values, y_sample_values, alternative='two-sided')
                    mann_u_file.write(f'{combo_name}\t{enzyme_name_x}\t{p_value}\n')
                else:
                    print(f"Warning: Not enough samples for {combo_name} {enzyme_name_x}. Skipping Mann-Whitney U test.")

    # Filter significant combinations for size 2, 3, and 4
    m_value = 0.5
    for combination_size in [2, 3, 4]:
        mann_u_file_name = f'{prefix}MannU{combination_size}.tsv'
        sig_combo_file_name = f'{prefix}sig_combo{combination_size}.tsv'

        with open(mann_u_file_name, 'r') as mann_u_file, \
             open(sig_combo_file_name, 'w') as output_file:

            output_file.write('\t'.join([f'Enzyme1-Enzyme2{"-Enzyme3" if combination_size >= 3 else ""}{"-Enzyme4" if combination_size >= 4 else ""}', 'Enzyme Name', 'Mann U']) + '\n')

            # Read all lines from the Mann-Whitney U file
            mann_u_lines = mann_u_file.readlines()[1:]  # Skip header
            mann_u_data = [line.strip().split('\t') for line in mann_u_lines]

            # Group p-values by enzyme combination
            combo_dict = {}
            for line in mann_u_data:
                combo_name = line[0]
                enzyme_name = line[1]
                mann_u_value = float(line[2])
                if combo_name not in combo_dict:
                    combo_dict[combo_name] = []
                combo_dict[combo_name].append((enzyme_name, mann_u_value))

            # Write all enzymes in the combination if any meet the threshold
            for combo_name, enzymes in combo_dict.items():
                # Check if any enzyme in the combination meets the threshold
                if any(mann_u_value < m_value for _, mann_u_value in enzymes):
                    for enzyme_name, mann_u_value in enzymes:
                        if mann_u_value < m_value:
                            output_file.write(f'{combo_name}\t{enzyme_name}\t{mann_u_value}\n')

if __name__ == "__main__":
    main()

from scipy.stats import binom, mannwhitneyu

def calculate_binomial_distribution(k, n, p):
    return binom.pmf(k, n, p)

def extract_values(sample_name, pollution_data):
    for row in pollution_data:
        if row[0] == sample_name:
            return float(row[1])
    raise ValueError(f"Sample '{sample_name}' not found in pollution data.")

def main():
    n = 10

    # Read enzyme percentages
    with open('p_sorted_normalized.tsv', 'r') as enzyme_file:
        enzyme_names = enzyme_file.readline().strip().split('\t')[1:]
        enzyme_percentages = {}
        for line in enzyme_file:
            values = line.strip().split('\t')
            enzyme_name = values[0]
            positive_values = sum(1 for value in values[1:] if float(value) > 0)
            enzyme_percentages[enzyme_name] = positive_values / 243

    # Process input file and write outputs
    with open('p_single.tsv', 'r') as input_file, \
         open('p_combo2.tsv', 'w') as output_file, \
         open('p_Wilcoxon_y-values2.tsv', 'w') as y_file, \
         open('p_Wilcoxon_y-samples2.tsv', 'w') as samples_file:

        sample_names = input_file.readline().strip().split('\t')[1:]
        output_file.write('\t'.join(['Enzyme1', 'Enzyme2', 'Count Percentage', 'Matches', 'Binomial Distribution', 'p_value']) + '\n')
        y_file.write('\t'.join(['Enzyme Pair', 'Values']) + '\n')

        lines = input_file.readlines()
        num_rows = len(lines)

        for i in range(num_rows - 1):
            for j in range(i + 1, num_rows):
                count_matches = 0
                positive_values = []

                for k in range(1, len(sample_names) + 1):
                    value_i = float(lines[i].strip().split('\t')[k])
                    value_j = float(lines[j].strip().split('\t')[k])

                    if value_i > 0 and value_j > 0:
                        count_matches += 1
                        positive_values.append(f'{value_i}, {value_j}')

                if count_matches >= n:
                    sample1 = lines[i].strip().split('\t')[0]
                    sample2 = lines[j].strip().split('\t')[0]
                    percentage_sample1 = enzyme_percentages.get(sample1, 0)
                    percentage_sample2 = enzyme_percentages.get(sample2, 0)
                    fraction = percentage_sample1 * percentage_sample2
                    distribution = calculate_binomial_distribution(count_matches, 41, fraction)
                    p_value = sum(calculate_binomial_distribution(k, 41, fraction) for k in range(count_matches, 42))

                    if p_value < 0.01:
                        output_file.write(f'{sample1}\t{sample2}\t{fraction}\t{count_matches}\t{distribution}\t{p_value}\n')
                        pair_name = f'{sample1}-{sample2}'
                        values_str = ', '.join(positive_values)
                        y_file.write(f'{pair_name}\t{values_str}\n')
                        for idx, value in enumerate(positive_values):
                            sample_name = sample_names[idx]
                            values_str = values_str.replace(value, sample_name)
                        samples_file.write(f'{pair_name}\t{values_str}\n')

    # Process y-values and x-values
    with open('p_Wilcoxon_y-values2.tsv', 'r') as y_file, \
         open('p_single.tsv', 'r') as sample_file, \
         open('p_Wilcoxon_x-values2.tsv', 'w') as x_output_file:

        y_values = {}
        next(y_file)
        for line in y_file:
            parts = line.strip().split('\t')
            pair_name = parts[0]
            values_str = parts[1]
            y_values[pair_name] = [float(value) for value in values_str.split(', ')]

        header = sample_file.readline().strip().split('\t')[1:]
        data = [line.strip().split('\t') for line in sample_file]

        x_output_file.write('\t'.join(['Enzyme Pair', 'Sample Name', 'Enzyme Name', 'Values']) + '\n')

        for pair_name, y_positive_values in y_values.items():
            sample_names = pair_name.split('-')
            for sample_name in sample_names:
                sample_row = next(row for row in data if row[0] == sample_name)
                sample_positive_values = [float(value) for value in sample_row[1:] if float(value) > 0]
                unique_values = set(sample_positive_values) - set(y_positive_values)

                if unique_values:
                    for value in unique_values:
                        enzyme_name = header[sample_row[1:].index(str(value)) - 1]
                        x_output_file.write(f'{pair_name}\t{enzyme_name}\t{sample_name}\t{value}\n')

    # Perform Mann-Whitney U test
    with open('pollution_abundance.tsv', 'r') as pollution_file, \
         open('p_Wilcoxon_y-samples2.tsv', 'r') as y_file, \
         open('p_Wilcoxon_x-values2.tsv', 'r') as x_file, \
         open('p_MannU2.tsv', 'w') as mann_u_file:

        next(pollution_file)
        pollution_data = [line.strip().split('\t') for line in pollution_file]

        y_values = {}
        for line in y_file:
            parts = line.strip().split('\t')
            pair_name = parts[0]
            values_str = parts[1]
            sample_values = []
            for sample_name in values_str.split(', '):
                try:
                    value = extract_values(sample_name, pollution_data)
                    sample_values.append(value)
                except ValueError as e:
                    print(f"Warning: {e}. Skipping this sample.")
                    continue
            y_values[pair_name] = sample_values

        x_values = {}
        next(x_file)
        for line in x_file:
            parts = line.strip().split('\t')
            pair_name = parts[0]
            sample_name = parts[1]
            enzyme_name = parts[2]
            try:
                value = extract_values(sample_name, pollution_data)
                key = f'{pair_name} {enzyme_name}'
                if key in x_values:
                    x_values[key].append(value)
                else:
                    x_values[key] = [value]
            except ValueError as e:
                print(f"Warning: {e}. Skipping this sample.")
                continue

        mann_u_file.write('\t'.join(['Enzyme Pair', 'Enzyme Name', 'Mann U']) + '\n')
        for key, x_sample_values in x_values.items():
            pair_name, enzyme_name_x = key.split()
            y_sample_values = y_values.get(pair_name, [])
            if len(x_sample_values) >= 2 and len(y_sample_values) >= 2:
                stat, p_value = mannwhitneyu(x_sample_values, y_sample_values, alternative='two-sided')
                mann_u_file.write(f'{pair_name}\t{enzyme_name_x}\t{p_value}\n')
            else:
                print(f"Warning: Not enough samples for {pair_name} {enzyme_name_x}. Skipping Mann-Whitney U test.")

    # Filter significant combinations
    m_value = .3
    with open('p_MannU2.tsv', 'r') as mann_u_file, \
         open('p_sig_combo2.tsv', 'w') as output_file:

        output_file.write('\t'.join(['Enzyme Pair', 'Enzyme Name', 'Mann U']) + '\n')
        next(mann_u_file)
        for line in mann_u_file:
            values = line.strip().split('\t')
            enzyme_pair = values[0]
            enzyme_name = values[1]
            mann_u_value = float(values[2])
            if mann_u_value < m_value:
                next_values = next(mann_u_file, None)
                if next_values is not None:
                    next_values = next_values.strip().split('\t')
                    next_enzyme_name = next_values[1]
                    next_mann_u_value = float(next_values[2])
                    if next_mann_u_value < m_value:
                        output_file.write('\t'.join([enzyme_pair, enzyme_name, str(mann_u_value)]) + '\n')
                        output_file.write('\t'.join([enzyme_pair, next_enzyme_name, str(next_mann_u_value)]) + '\n')

if __name__ == "__main__":
    main()

from scipy.stats import binom, mannwhitneyu
from itertools import combinations

def calculate_binomial_distribution(k, n, p):
    return binom.pmf(k, n, p)

def main():
    n = 10

    # Read enzyme percentages
    with open('p_sorted_normalized.tsv', 'r') as enzyme_file:
        enzyme_names = enzyme_file.readline().strip().split('\t')[1:]
        enzyme_percentages = {}
        for line in enzyme_file:
            values = line.strip().split('\t')
            enzyme_name = values[0]
            positive_values = sum(1 for value in values[1:] if float(value) > 0)
            enzyme_percentages[enzyme_name] = positive_values / 243

    # Process input file and write outputs
    with open('p_single.tsv', 'r') as input_file, \
         open('p_combo3.tsv', 'w') as output_file, \
         open('p_Wilcoxon_y-values3.tsv', 'w') as y_file, \
         open('p_Wilcoxon_y-samples3.tsv', 'w') as samples_file:

        sample_names = input_file.readline().strip().split('\t')[1:]
        output_file.write('\t'.join(['Enzyme1', 'Enzyme2', 'Enzyme3', 'Count Percentage', 'Matches', 'Binomial Distribution', 'p_value']) + '\n')
        y_file.write('\t'.join(['Enzyme Trio', 'Values']) + '\n')

        lines = input_file.readlines()
        num_rows = len(lines)

        for combo in combinations(range(num_rows), 3):
            i, j, k = combo

            count_matches = 0
            positive_values = []

            for m in range(1, len(sample_names) + 1):
                value_i = float(lines[i].strip().split('\t')[m])
                value_j = float(lines[j].strip().split('\t')[m])
                value_k = float(lines[k].strip().split('\t')[m])

                if all(value > 0 for value in [value_i, value_j, value_k]):
                    count_matches += 1
                    positive_values.append(f'{value_i}, {value_j}, {value_k}')

            if count_matches >= n:
                sample1 = lines[i].strip().split('\t')[0]
                sample2 = lines[j].strip().split('\t')[0]
                sample3 = lines[k].strip().split('\t')[0]

                percentage_sample1 = enzyme_percentages.get(sample1, 0)
                percentage_sample2 = enzyme_percentages.get(sample2, 0)
                percentage_sample3 = enzyme_percentages.get(sample3, 0)

                fraction = percentage_sample1 * percentage_sample2 * percentage_sample3

                distribution = calculate_binomial_distribution(count_matches, 41, fraction)
                p_value = sum(calculate_binomial_distribution(k, 41, fraction) for k in range(count_matches, 42))

                if p_value < 0.01:
                    output_file.write(f'{sample1}\t{sample2}\t{sample3}\t{fraction}\t{count_matches}\t{distribution}\t{p_value}\n')

                    trio_name = f'{sample1}-{sample2}-{sample3}'
                    values_str = ', '.join(positive_values)
                    y_file.write(f'{trio_name}\t{values_str}\n')

                    for idx, value in enumerate(positive_values):
                        sample_name = sample_names[idx]
                        values_str = values_str.replace(value, sample_name)

                    samples_file.write(f'{trio_name}\t{values_str}\n')

    # Process y-values and x-values
    with open('p_Wilcoxon_y-values3.tsv', 'r') as y_file, \
         open('p_single.tsv', 'r') as sample_file, \
         open('p_Wilcoxon_x-values3.tsv', 'w') as x_output_file:

        y_values = {}
        next(y_file)
        for line in y_file:
            parts = line.strip().split('\t')
            set_name = parts[0]
            values_str = parts[1]
            y_values[set_name] = set(values_str.split(', '))

        header = sample_file.readline().strip().split('\t')[1:]
        data = [line.strip().split('\t') for line in sample_file]

        x_output_file.write('\t'.join(['Enzyme Set', 'Sample Name', 'Values']) + '\n')

        for set_name, y_positive_values in y_values.items():
            sample_names = set_name.split('-')
            for sample_name in sample_names:
                sample_row = next(row for row in data if row[0] == sample_name)
                sample_positive_values = [float(value) for value in sample_row[1:] if float(value) > 0]
                unique_values = set(sample_positive_values) - y_positive_values

                if unique_values:
                    x_output_file.write(f'{set_name}\t{sample_name}\t{" ".join(map(str, unique_values))}\n')

    # Prepare pollution values
    with open('pollution_abundance.tsv', 'r') as pollution_file:
        next(pollution_file)
        pollution_values = {sample_name: float(abundance) for sample_name, abundance in [line.strip().split('\t') for line in pollution_file]}

    # Prepare y_values from p_Wilcoxon_y-samples3.tsv
    y_values = {}
    with open('p_Wilcoxon_y-samples3.tsv', 'r') as y_file:
        for line in y_file:
            parts = line.strip().split('\t')
            set_name = parts[0]
            values_str = parts[1]
            sample_values = [pollution_values[sample_name] for sample_name in values_str.split(', ') if sample_name in pollution_values]
            y_values[set_name] = sample_values

    # Prepare x_values from p_Wilcoxon_x-values3.tsv
    x_values = {}
    with open('p_Wilcoxon_x-values3.tsv', 'r') as x_file:
        next(x_file)
        for line in x_file:
            parts = line.strip().split('\t')
            set_name = parts[0]
            sample_name = parts[1]
            enzyme_name = parts[2]

            if sample_name in pollution_values:
                value = pollution_values[sample_name]
                key = f'{set_name} {enzyme_name}'
                if key in x_values:
                    x_values[key].append(value)
                else:
                    x_values[key] = [value]

    # Perform Mann-Whitney U test
    with open('p_MannU3.tsv', 'w') as mann_u_file:
        mann_u_file.write('\t'.join(['Enzyme Set', 'Enzyme Name', 'Mann U']) + '\n')

        for key, x_sample_values in x_values.items():
            set_name, enzyme_name_x = key.split()
            y_sample_values = y_values.get(set_name, [])

            if len(x_sample_values) >= 2 and len(y_sample_values) >= 2:
                stat, p_value = mannwhitneyu(x_sample_values, y_sample_values, alternative='two-sided')
                mann_u_file.write(f'{set_name}\t{enzyme_name_x}\t{p_value}\n')

    # Filter significant combinations
    with open('p_MannU3.tsv', 'r') as mann_u_file, \
         open('p_sig_combo3.tsv', 'w') as output_file:

        output_file.write('\t'.join(['Enzyme Pair', 'Enzyme Name', 'Mann U']) + '\n')
        next(mann_u_file)

        while True:
            line1 = next(mann_u_file, None)
            line2 = next(mann_u_file, None)
            line3 = next(mann_u_file, None)

            if not (line1 and line2 and line3):
                break

            values1 = line1.strip().split('\t')
            values2 = line2.strip().split('\t')
            values3 = line3.strip().split('\t')

            enzyme_pair = values1[0]
            enzyme_name1 = values1[1]
            mann_u_value1 = float(values1[2])

            enzyme_name2 = values2[1]
            mann_u_value2 = float(values2[2])

            enzyme_name3 = values3[1]
            mann_u_value3 = float(values3[2])

            if mann_u_value1 < 0.1 and mann_u_value2 < 0.1 and mann_u_value3 < 0.1:
                output_file.write(f'{enzyme_pair}\t{enzyme_name1}\t{mann_u_value1}\n')
                output_file.write(f'{enzyme_pair}\t{enzyme_name2}\t{mann_u_value2}\n')
                output_file.write(f'{enzyme_pair}\t{enzyme_name3}\t{mann_u_value3}\n')

if __name__ == "__main__":
    main()

from scipy.stats import binom, mannwhitneyu
from itertools import combinations

def calculate_binomial_distribution(k, n, p):
    return binom.pmf(k, n, p)

def extract_values(sample_name, pollution_data):
    for row in pollution_data:
        if row[0] == sample_name:
            return float(row[1])
    raise ValueError(f"Sample '{sample_name}' not found in pollution data.")

def main():
    n = 10

    # Read enzyme percentages
    with open('p_sorted_normalized.tsv', 'r') as enzyme_file:
        enzyme_names = enzyme_file.readline().strip().split('\t')[1:]
        enzyme_percentages = {}
        for line in enzyme_file:
            values = line.strip().split('\t')
            enzyme_name = values[0]
            positive_values = sum(1 for value in values[1:] if float(value) > 0)
            enzyme_percentages[enzyme_name] = positive_values / 243

    # Process input file and write outputs
    with open('p_single.tsv', 'r') as input_file, \
         open('p_combo4.tsv', 'w') as output_file, \
         open('p_Wilcoxon_y-values4.tsv', 'w') as y_file, \
         open('p_Wilcoxon_y-samples4.tsv', 'w') as samples_file:

        sample_names = input_file.readline().strip().split('\t')[1:]
        output_file.write('\t'.join(['Enzyme1', 'Enzyme2', 'Enzyme3', 'Enzyme4', 'Count Percentage', 'Matches', 'Binomial Distribution', 'p_value']) + '\n')
        y_file.write('\t'.join(['Enzyme Quadruplet', 'Values']) + '\n')

        lines = input_file.readlines()
        num_rows = len(lines)

        for combo in combinations(range(num_rows), 4):
            i, j, k, l = combo
            count_matches = 0
            positive_values = []

            for m in range(1, len(sample_names) + 1):
                values = [float(lines[idx].strip().split('\t')[m]) for idx in combo]
                if all(value > 0 for value in values):
                    count_matches += 1
                    positive_values.append(', '.join(map(str, values)))

            if count_matches >= n:
                samples = [lines[idx].strip().split('\t')[0] for idx in combo]
                percentages = [enzyme_percentages.get(sample, 0) for sample in samples]
                fraction = percentages[0] * percentages[1] * percentages[2] * percentages[3]
                distribution = calculate_binomial_distribution(count_matches, 41, fraction)
                p_value = sum(calculate_binomial_distribution(k, 41, fraction) for k in range(count_matches, 42))

                if p_value < 0.01:
                    output_file.write(f'{samples[0]}\t{samples[1]}\t{samples[2]}\t{samples[3]}\t{fraction}\t{count_matches}\t{distribution}\t{p_value}\n')
                    quadruplet_name = '-'.join(samples)
                    values_str = ', '.join(positive_values)
                    y_file.write(f'{quadruplet_name}\t{values_str}\n')
                    for idx, value in enumerate(positive_values):
                        sample_name = sample_names[idx]
                        values_str = values_str.replace(value, sample_name)
                    samples_file.write(f'{quadruplet_name}\t{values_str}\n')

    # Process y-values and x-values
    with open('p_Wilcoxon_y-values4.tsv', 'r') as y_file, \
         open('p_single.tsv', 'r') as sample_file, \
         open('p_Wilcoxon_x-values4.tsv', 'w') as x_output_file:

        y_values = {}
        next(y_file)
        for line in y_file:
            parts = line.strip().split('\t')
            quadruplet_name = parts[0]
            values_str = parts[1]
            y_values[quadruplet_name] = [float(value) for value in values_str.split(', ')]

        header = sample_file.readline().strip().split('\t')[1:]
        data = [line.strip().split('\t') for line in sample_file]

        x_output_file.write('\t'.join(['Enzyme Quadruplet', 'Sample Name', 'Enzyme Name', 'Values']) + '\n')

        for quadruplet_name, y_positive_values in y_values.items():
            sample_names = quadruplet_name.split('-')
            for sample_name in sample_names:
                sample_row = next(row for row in data if row[0] == sample_name)
                sample_positive_values = [float(value) for value in sample_row[1:] if float(value) > 0]
                unique_values = set(sample_positive_values) - set(y_positive_values)

                if unique_values:
                    for value in unique_values:
                        enzyme_name = header[sample_row[1:].index(str(value)) - 1]
                        x_output_file.write(f'{quadruplet_name}\t{enzyme_name}\t{sample_name}\t{value}\n')

    # Perform Mann-Whitney U test
    with open('pollution_abundance.tsv', 'r') as pollution_file, \
         open('p_Wilcoxon_y-samples4.tsv', 'r') as y_file, \
         open('p_Wilcoxon_x-values4.tsv', 'r') as x_file, \
         open('p_MannU4.tsv', 'w') as mann_u_file:

        next(pollution_file)
        pollution_data = [line.strip().split('\t') for line in pollution_file]

        y_values = {}
        for line in y_file:
            parts = line.strip().split('\t')
            quadruplet_name = parts[0]
            values_str = parts[1]
            sample_values = []
            for sample_name in values_str.split(', '):
                try:
                    value = extract_values(sample_name, pollution_data)
                    sample_values.append(value)
                except ValueError as e:
                    print(f"Warning: {e}. Skipping this sample.")
                    continue
            y_values[quadruplet_name] = sample_values

        x_values = {}
        next(x_file)
        for line in x_file:
            parts = line.strip().split('\t')
            quadruplet_name = parts[0]
            sample_name = parts[1]
            enzyme_name = parts[2]
            try:
                value = extract_values(sample_name, pollution_data)
                key = f'{quadruplet_name} {enzyme_name}'
                if key in x_values:
                    x_values[key].append(value)
                else:
                    x_values[key] = [value]
            except ValueError as e:
                print(f"Warning: {e}. Skipping this sample.")
                continue

        mann_u_file.write('\t'.join(['Enzyme Quadruplet', 'Enzyme Name', 'Mann U']) + '\n')
        for key, x_sample_values in x_values.items():
            quadruplet_name, enzyme_name_x = key.split()
            y_sample_values = y_values.get(quadruplet_name, [])
            if len(x_sample_values) >= 2 and len(y_sample_values) >= 2:
                stat, p_value = mannwhitneyu(x_sample_values, y_sample_values, alternative='two-sided')
                mann_u_file.write(f'{quadruplet_name}\t{enzyme_name_x}\t{p_value}\n')
            else:
                print(f"Warning: Not enough samples for {quadruplet_name} {enzyme_name_x}. Skipping Mann-Whitney U test.")

    # Filter significant combinations
    m_value = 0.1
    with open('p_MannU4.tsv', 'r') as mann_u_file, \
         open('p_sig_combo4.tsv', 'w') as output_file:

        output_file.write('\t'.join(['Enzyme Quadruplet', 'Enzyme Name', 'Mann U']) + '\n')
        next(mann_u_file)
        for line in mann_u_file:
            values = line.strip().split('\t')
            enzyme_quadruplet = values[0]
            enzyme_name = values[1]
            mann_u_value = float(values[2])
            if mann_u_value < m_value:
                next_values = next(mann_u_file, None)
                if next_values is not None:
                    next_values = next_values.strip().split('\t')
                    next_enzyme_name = next_values[1]
                    next_mann_u_value = float(next_values[2])
                    if next_mann_u_value < m_value:
                        output_file.write('\t'.join([enzyme_quadruplet, enzyme_name, str(mann_u_value)]) + '\n')
                        output_file.write('\t'.join([enzyme_quadruplet, next_enzyme_name, str(next_mann_u_value)]) + '\n')

if __name__ == "__main__":
    main()

"""# Combination Analysis using Spearman Correlations"""

import pandas as pd

# Step 1: Read enzyme names from the sig_pearson_enzymes.tsv file
enzyme_names = []
with open('sig_spearman_enzymes.tsv', 'r') as file:
    # Skip the header if necessary
    next(file)  # If there's a header, use this line to skip it
    for line in file:
        data = line.strip().split('\t')  # Assuming tab-delimited file
        enzyme = data[0]  # Assuming enzyme ID is in the first column
        enzyme_names.append(enzyme)

# Step 2: Read the enzyme abundance file and filter rows based on the enzyme names
release_df = pd.read_csv("enzyme_abundance.tsv", sep='\t')

# Create a filtered DataFrame containing only the rows with enzyme names present in the enzyme_names list
filtered_df = release_df[release_df['ko'].isin(enzyme_names)]

# Step 3: Calculate mean and standard deviation for each enzyme and store them in a dictionary
output_data = []

# Calculate mean and standard deviation for each row and store the results
for enzyme in enzyme_names:
    enzyme_rows = filtered_df[filtered_df['ko'] == enzyme]  # Filter rows for each enzyme
    means = enzyme_rows.iloc[:, 1:].mean(axis=1)  # Mean across the abundance columns
    std_devs = enzyme_rows.iloc[:, 1:].std(axis=1)  # Standard deviation across the abundance columns
    for mean, std_dev in zip(means, std_devs):
        output_data.append([enzyme, mean, std_dev])

# Step 4: Create a DataFrame for the mean and standard deviation and write it to a .tsv file
output_df = pd.DataFrame(output_data, columns=["Enzyme", "Mean", "Standard Deviation"])
output_df.to_csv("s_mean_sd.tsv", sep='\t', index=False)

print("Mean and SD saved to s_mean_sd.tsv")

# Step 5: Normalize the abundance data based on the calculated mean and standard deviation
mean_sd_values = {enzyme: {'mean': mean, 'std_dev': std_dev} for enzyme, mean, std_dev in zip(output_df['Enzyme'], output_df['Mean'], output_df['Standard Deviation'])}

# Step 6: Normalize the abundance data
normalized_data = []

for idx, row in filtered_df.iterrows():
    enzyme = row['ko']  # Enzyme ID
    if enzyme in mean_sd_values:
        mean = mean_sd_values[enzyme]['mean']
        std_dev = mean_sd_values[enzyme]['std_dev']

        # Normalize the abundance values (columns other than 'ko')
        normalized_row = [enzyme]  # Start with the enzyme ID
        for value in row[1:]:  # Skip the 'ko' column and normalize each abundance value
            normalized_value = (value - mean) / std_dev if std_dev != 0 else 0
            normalized_row.append(normalized_value)

        normalized_data.append(normalized_row)

# Step 7: Create a DataFrame for the normalized data and save it to a new file
normalized_df = pd.DataFrame(normalized_data, columns=filtered_df.columns)
normalized_df.to_csv("s_normalized_abundance.tsv", sep='\t', index=False)

print("Normalized data saved to 's_normalized_abundance.tsv'")

# Step 8: Sort rows based on the number of positive values (excluding the enzyme ID)
def count_positive(row):
    return sum(1 for value in row[1:] if float(value) > 0)

# List to store data rows
data_rows = []
with open('s_normalized_abundance.tsv', 'r') as sorted_file:
    # Read the header (first row)
    header = sorted_file.readline().strip().split('\t')

    # Read and store the data rows
    for line in sorted_file:
        data_rows.append(line.strip().split('\t'))

# Sort data rows based on the number of positive values (excluding the enzyme ID)
sorted_rows = sorted(data_rows, key=count_positive, reverse=True)

# Step 9: Write sorted data to a new file
with open('s_sorted_normalized.tsv', 'w') as output_file:
    # Write the header (first row)
    output_file.write('\t'.join(header) + '\n')

    # Write the sorted rows
    for row in sorted_rows:
        output_file.write('\t'.join(row) + '\n')

print("Sorted data based on the number of positive values written to 's_sorted_normalized.tsv'")

# Step 10: Finding enzymes that have at least 10 positive values in their row
n = 10

with open('s_sorted_normalized.tsv', 'r') as input_file, open('s_single.tsv', 'w') as output_file:
    # Copy the first row to the output file
    first_row = input_file.readline()
    output_file.write(first_row)

    # Iterate through the remaining rows
    for line in input_file:
        values = line.strip().split('\t')

        # Count the number of positive values in the row (excluding the first column)
        count_positives = sum(float(value) > 0 for value in values[1:])

        # If the row has at least 'n' positive values, copy the entire row to the output file
        if count_positives >= n:
            output_file.write(line)

from scipy.stats import binom, mannwhitneyu

def calculate_binomial_distribution(k, n, p):
    return binom.pmf(k, n, p)

def extract_values(sample_name, pollution_data):
    for row in pollution_data:
        if row[0] == sample_name:
            return float(row[1])
    raise ValueError(f"Sample '{sample_name}' not found in pollution data.")

def main():
    n = 10

    # Read enzyme percentages
    with open('s_sorted_normalized.tsv', 'r') as enzyme_file:
        enzyme_names = enzyme_file.readline().strip().split('\t')[1:]
        enzyme_percentages = {}
        for line in enzyme_file:
            values = line.strip().split('\t')
            enzyme_name = values[0]
            positive_values = sum(1 for value in values[1:] if float(value) > 0)
            enzyme_percentages[enzyme_name] = positive_values / 243

    # Process input file and write outputs
    with open('s_single.tsv', 'r') as input_file, \
         open('s_combo2.tsv', 'w') as output_file, \
         open('s_Wilcoxon_y-values2.tsv', 'w') as y_file, \
         open('s_Wilcoxon_y-samples2.tsv', 'w') as samples_file:

        sample_names = input_file.readline().strip().split('\t')[1:]
        output_file.write('\t'.join(['Enzyme1', 'Enzyme2', 'Count Percentage', 'Matches', 'Binomial Distribution', 'p_value']) + '\n')
        y_file.write('\t'.join(['Enzyme Pair', 'Values']) + '\n')

        lines = input_file.readlines()
        num_rows = len(lines)

        for i in range(num_rows - 1):
            for j in range(i + 1, num_rows):
                count_matches = 0
                positive_values = []

                for k in range(1, len(sample_names) + 1):
                    value_i = float(lines[i].strip().split('\t')[k])
                    value_j = float(lines[j].strip().split('\t')[k])

                    if value_i > 0 and value_j > 0:
                        count_matches += 1
                        positive_values.append(f'{value_i}, {value_j}')

                if count_matches >= n:
                    sample1 = lines[i].strip().split('\t')[0]
                    sample2 = lines[j].strip().split('\t')[0]
                    percentage_sample1 = enzyme_percentages.get(sample1, 0)
                    percentage_sample2 = enzyme_percentages.get(sample2, 0)
                    fraction = percentage_sample1 * percentage_sample2
                    distribution = calculate_binomial_distribution(count_matches, 41, fraction)
                    p_value = sum(calculate_binomial_distribution(k, 41, fraction) for k in range(count_matches, 42))

                    if p_value < 0.01:
                        output_file.write(f'{sample1}\t{sample2}\t{fraction}\t{count_matches}\t{distribution}\t{p_value}\n')
                        pair_name = f'{sample1}-{sample2}'
                        values_str = ', '.join(positive_values)
                        y_file.write(f'{pair_name}\t{values_str}\n')
                        for idx, value in enumerate(positive_values):
                            sample_name = sample_names[idx]
                            values_str = values_str.replace(value, sample_name)
                        samples_file.write(f'{pair_name}\t{values_str}\n')

    # Process y-values and x-values
    with open('s_Wilcoxon_y-values2.tsv', 'r') as y_file, \
         open('s_single.tsv', 'r') as sample_file, \
         open('s_Wilcoxon_x-values2.tsv', 'w') as x_output_file:

        y_values = {}
        next(y_file)
        for line in y_file:
            parts = line.strip().split('\t')
            pair_name = parts[0]
            values_str = parts[1]
            y_values[pair_name] = [float(value) for value in values_str.split(', ')]

        header = sample_file.readline().strip().split('\t')[1:]
        data = [line.strip().split('\t') for line in sample_file]

        x_output_file.write('\t'.join(['Enzyme Pair', 'Sample Name', 'Enzyme Name', 'Values']) + '\n')

        for pair_name, y_positive_values in y_values.items():
            sample_names = pair_name.split('-')
            for sample_name in sample_names:
                sample_row = next(row for row in data if row[0] == sample_name)
                sample_positive_values = [float(value) for value in sample_row[1:] if float(value) > 0]
                unique_values = set(sample_positive_values) - set(y_positive_values)

                if unique_values:
                    for value in unique_values:
                        enzyme_name = header[sample_row[1:].index(str(value)) - 1]
                        x_output_file.write(f'{pair_name}\t{enzyme_name}\t{sample_name}\t{value}\n')

    # Perform Mann-Whitney U test
    with open('pollution_abundance.tsv', 'r') as pollution_file, \
         open('s_Wilcoxon_y-samples2.tsv', 'r') as y_file, \
         open('s_Wilcoxon_x-values2.tsv', 'r') as x_file, \
         open('s_MannU2.tsv', 'w') as mann_u_file:

        next(pollution_file)
        pollution_data = [line.strip().split('\t') for line in pollution_file]

        y_values = {}
        for line in y_file:
            parts = line.strip().split('\t')
            pair_name = parts[0]
            values_str = parts[1]
            sample_values = []
            for sample_name in values_str.split(', '):
                try:
                    value = extract_values(sample_name, pollution_data)
                    sample_values.append(value)
                except ValueError as e:
                    print(f"Warning: {e}. Skipping this sample.")
                    continue
            y_values[pair_name] = sample_values

        x_values = {}
        next(x_file)
        for line in x_file:
            parts = line.strip().split('\t')
            pair_name = parts[0]
            sample_name = parts[1]
            enzyme_name = parts[2]
            try:
                value = extract_values(sample_name, pollution_data)
                key = f'{pair_name} {enzyme_name}'
                if key in x_values:
                    x_values[key].append(value)
                else:
                    x_values[key] = [value]
            except ValueError as e:
                print(f"Warning: {e}. Skipping this sample.")
                continue

        mann_u_file.write('\t'.join(['Enzyme Pair', 'Enzyme Name', 'Mann U']) + '\n')
        for key, x_sample_values in x_values.items():
            pair_name, enzyme_name_x = key.split()
            y_sample_values = y_values.get(pair_name, [])
            if len(x_sample_values) >= 2 and len(y_sample_values) >= 2:
                stat, p_value = mannwhitneyu(x_sample_values, y_sample_values, alternative='two-sided')
                mann_u_file.write(f'{pair_name}\t{enzyme_name_x}\t{p_value}\n')
            else:
                print(f"Warning: Not enough samples for {pair_name} {enzyme_name_x}. Skipping Mann-Whitney U test.")

    # Filter significant combinations
    m_value = .3
    with open('s_MannU2.tsv', 'r') as mann_u_file, \
         open('s_sig_combo2.tsv', 'w') as output_file:

        output_file.write('\t'.join(['Enzyme Pair', 'Enzyme Name', 'Mann U']) + '\n')
        next(mann_u_file)
        for line in mann_u_file:
            values = line.strip().split('\t')
            enzyme_pair = values[0]
            enzyme_name = values[1]
            mann_u_value = float(values[2])
            if mann_u_value < m_value:
                next_values = next(mann_u_file, None)
                if next_values is not None:
                    next_values = next_values.strip().split('\t')
                    next_enzyme_name = next_values[1]
                    next_mann_u_value = float(next_values[2])
                    if next_mann_u_value < m_value:
                        output_file.write('\t'.join([enzyme_pair, enzyme_name, str(mann_u_value)]) + '\n')
                        output_file.write('\t'.join([enzyme_pair, next_enzyme_name, str(next_mann_u_value)]) + '\n')

if __name__ == "__main__":
    main()

"""### Redoing 2 and 3"""

from scipy.stats import binom, mannwhitneyu
from itertools import combinations

def calculate_binomial_distribution(k, n, p):
    return binom.pmf(k, n, p)

def main():
    # Define adjustable parameters
    n = 10  # Minimum number of matches required for a triplet to be considered
    mann_whitney_threshold = 0.3  # Threshold for Mann-Whitney U test significance

    # Read enzyme percentages
    with open('p_sorted_normalized.tsv', 'r') as enzyme_file:
        enzyme_names = enzyme_file.readline().strip().split('\t')[1:]
        enzyme_percentages = {}
        for line in enzyme_file:
            values = line.strip().split('\t')
            enzyme_name = values[0]
            positive_values = sum(1 for value in values[1:] if float(value) > 0)
            enzyme_percentages[enzyme_name] = positive_values / 243

    # Process input file and write outputs
    with open('s_single.tsv', 'r') as input_file, \
         open('s_combo3.tsv', 'w') as output_file, \
         open('s_Wilcoxon_y-values3.tsv', 'w') as y_file, \
         open('s_Wilcoxon_y-samples3.tsv', 'w') as samples_file:

        sample_names = input_file.readline().strip().split('\t')[1:]
        output_file.write('\t'.join(['Enzyme1', 'Enzyme2', 'Enzyme3', 'Count Percentage', 'Matches', 'Binomial Distribution', 'p_value']) + '\n')
        y_file.write('\t'.join(['Enzyme Trio', 'Values']) + '\n')

        lines = input_file.readlines()
        num_rows = len(lines)

        for combo in combinations(range(num_rows), 3):
            i, j, k = combo

            count_matches = 0
            positive_values = []

            for m in range(1, len(sample_names) + 1):
                value_i = float(lines[i].strip().split('\t')[m])
                value_j = float(lines[j].strip().split('\t')[m])
                value_k = float(lines[k].strip().split('\t')[m])

                if all(value > 0 for value in [value_i, value_j, value_k]):
                    count_matches += 1
                    positive_values.append(f'{value_i}, {value_j}, {value_k}')

            if count_matches >= n:
                sample1 = lines[i].strip().split('\t')[0]
                sample2 = lines[j].strip().split('\t')[0]
                sample3 = lines[k].strip().split('\t')[0]

                percentage_sample1 = enzyme_percentages.get(sample1, 0)
                percentage_sample2 = enzyme_percentages.get(sample2, 0)
                percentage_sample3 = enzyme_percentages.get(sample3, 0)

                fraction = percentage_sample1 * percentage_sample2 * percentage_sample3

                distribution = calculate_binomial_distribution(count_matches, 41, fraction)
                p_value = sum(calculate_binomial_distribution(k, 41, fraction) for k in range(count_matches, 42))

                if p_value < 0.01:
                    output_file.write(f'{sample1}\t{sample2}\t{sample3}\t{fraction}\t{count_matches}\t{distribution}\t{p_value}\n')

                    trio_name = f'{sample1}-{sample2}-{sample3}'
                    values_str = ', '.join(positive_values)
                    y_file.write(f'{trio_name}\t{values_str}\n')

                    for idx, value in enumerate(positive_values):
                        sample_name = sample_names[idx]
                        values_str = values_str.replace(value, sample_name)

                    samples_file.write(f'{trio_name}\t{values_str}\n')

    # Process y-values and x-values
    with open('s_Wilcoxon_y-values3.tsv', 'r') as y_file, \
         open('s_single.tsv', 'r') as sample_file, \
         open('s_Wilcoxon_x-values3.tsv', 'w') as x_output_file:

        y_values = {}
        next(y_file)
        for line in y_file:
            parts = line.strip().split('\t')
            set_name = parts[0]
            values_str = parts[1]
            y_values[set_name] = set(values_str.split(', '))

        header = sample_file.readline().strip().split('\t')[1:]
        data = [line.strip().split('\t') for line in sample_file]

        x_output_file.write('\t'.join(['Enzyme Set', 'Sample Name', 'Values']) + '\n')

        for set_name, y_positive_values in y_values.items():
            sample_names = set_name.split('-')
            for sample_name in sample_names:
                sample_row = next(row for row in data if row[0] == sample_name)
                sample_positive_values = [float(value) for value in sample_row[1:] if float(value) > 0]
                unique_values = set(sample_positive_values) - y_positive_values

                if unique_values:
                    x_output_file.write(f'{set_name}\t{sample_name}\t{" ".join(map(str, unique_values))}\n')

    # Prepare pollution values
    with open('pollution_abundance.tsv', 'r') as pollution_file:
        next(pollution_file)
        pollution_values = {sample_name: float(abundance) for sample_name, abundance in [line.strip().split('\t') for line in pollution_file]}

    # Prepare y_values from p_Wilcoxon_y-samples3.tsv
    y_values = {}
    with open('s_Wilcoxon_y-samples3.tsv', 'r') as y_file:
        for line in y_file:
            parts = line.strip().split('\t')
            set_name = parts[0]
            values_str = parts[1]
            sample_values = [pollution_values[sample_name] for sample_name in values_str.split(', ') if sample_name in pollution_values]
            y_values[set_name] = sample_values

    # Prepare x_values from p_Wilcoxon_x-values3.tsv
    x_values = {}
    with open('s_Wilcoxon_x-values3.tsv', 'r') as x_file:
        next(x_file)
        for line in x_file:
            parts = line.strip().split('\t')
            set_name = parts[0]
            sample_name = parts[1]
            enzyme_name = parts[2]

            if sample_name in pollution_values:
                value = pollution_values[sample_name]
                key = f'{set_name} {enzyme_name}'
                if key in x_values:
                    x_values[key].append(value)
                else:
                    x_values[key] = [value]

    # Perform Mann-Whitney U test
    with open('s_MannU3.tsv', 'w') as mann_u_file:
        mann_u_file.write('\t'.join(['Enzyme Set', 'Enzyme Name', 'Mann U']) + '\n')

        for key, x_sample_values in x_values.items():
            set_name, enzyme_name_x = key.split()
            y_sample_values = y_values.get(set_name, [])

            if len(x_sample_values) >= 2 and len(y_sample_values) >= 2:
                stat, p_value = mannwhitneyu(x_sample_values, y_sample_values, alternative='two-sided')
                mann_u_file.write(f'{set_name}\t{enzyme_name_x}\t{p_value}\n')

    # Filter significant combinations
    with open('s_MannU3.tsv', 'r') as mann_u_file, \
         open('s_sig_combo3.tsv', 'w') as output_file:

        output_file.write('\t'.join(['Enzyme Pair', 'Enzyme Name', 'Mann U']) + '\n')
        next(mann_u_file)

        while True:
            line1 = next(mann_u_file, None)
            line2 = next(mann_u_file, None)
            line3 = next(mann_u_file, None)

            if not (line1 and line2 and line3):
                break

            values1 = line1.strip().split('\t')
            values2 = line2.strip().split('\t')
            values3 = line3.strip().split('\t')

            enzyme_pair = values1[0]
            enzyme_name1 = values1[1]
            mann_u_value1 = float(values1[2])

            enzyme_name2 = values2[1]
            mann_u_value2 = float(values2[2])

            enzyme_name3 = values3[1]
            mann_u_value3 = float(values3[2])

            if mann_u_value1 < mann_whitney_threshold and mann_u_value2 < mann_whitney_threshold and mann_u_value3 < mann_whitney_threshold:
                output_file.write(f'{enzyme_pair}\t{enzyme_name1}\t{mann_u_value1}\n')
                output_file.write(f'{enzyme_pair}\t{enzyme_name2}\t{mann_u_value2}\n')
                output_file.write(f'{enzyme_pair}\t{enzyme_name3}\t{mann_u_value3}\n')

if __name__ == "__main__":
    main()

from scipy.stats import binom, mannwhitneyu
from itertools import combinations

def calculate_binomial_distribution(k, n, p):
    return binom.pmf(k, n, p)

def extract_values(sample_name, pollution_data):
    for row in pollution_data:
        if row[0] == sample_name:
            return float(row[1])
    raise ValueError(f"Sample '{sample_name}' not found in pollution data.")

def main():
    n = 10

    # Read enzyme percentages
    with open('s_sorted_normalized.tsv', 'r') as enzyme_file:
        enzyme_names = enzyme_file.readline().strip().split('\t')[1:]
        enzyme_percentages = {}
        for line in enzyme_file:
            values = line.strip().split('\t')
            enzyme_name = values[0]
            positive_values = sum(1 for value in values[1:] if float(value) > 0)
            enzyme_percentages[enzyme_name] = positive_values / 243

    # Process input file and write outputs
    with open('s_single.tsv', 'r') as input_file, \
         open('s_combo4.tsv', 'w') as output_file, \
         open('s_Wilcoxon_y-values4.tsv', 'w') as y_file, \
         open('s_Wilcoxon_y-samples4.tsv', 'w') as samples_file:

        sample_names = input_file.readline().strip().split('\t')[1:]
        output_file.write('\t'.join(['Enzyme1', 'Enzyme2', 'Enzyme3', 'Enzyme4', 'Count Percentage', 'Matches', 'Binomial Distribution', 'p_value']) + '\n')
        y_file.write('\t'.join(['Enzyme Quadruplet', 'Values']) + '\n')

        lines = input_file.readlines()
        num_rows = len(lines)

        for combo in combinations(range(num_rows), 4):
            i, j, k, l = combo
            count_matches = 0
            positive_values = []

            for m in range(1, len(sample_names) + 1):
                values = [float(lines[idx].strip().split('\t')[m]) for idx in combo]
                if all(value > 0 for value in values):
                    count_matches += 1
                    positive_values.append(', '.join(map(str, values)))

            if count_matches >= n:
                samples = [lines[idx].strip().split('\t')[0] for idx in combo]
                percentages = [enzyme_percentages.get(sample, 0) for sample in samples]
                fraction = percentages[0] * percentages[1] * percentages[2] * percentages[3]
                distribution = calculate_binomial_distribution(count_matches, 41, fraction)
                p_value = sum(calculate_binomial_distribution(k, 41, fraction) for k in range(count_matches, 42))

                if p_value < 0.01:
                    output_file.write(f'{samples[0]}\t{samples[1]}\t{samples[2]}\t{samples[3]}\t{fraction}\t{count_matches}\t{distribution}\t{p_value}\n')
                    quadruplet_name = '-'.join(samples)
                    values_str = ', '.join(positive_values)
                    y_file.write(f'{quadruplet_name}\t{values_str}\n')
                    for idx, value in enumerate(positive_values):
                        sample_name = sample_names[idx]
                        values_str = values_str.replace(value, sample_name)
                    samples_file.write(f'{quadruplet_name}\t{values_str}\n')

    # Process y-values and x-values
    with open('s_Wilcoxon_y-values4.tsv', 'r') as y_file, \
         open('s_single.tsv', 'r') as sample_file, \
         open('s_Wilcoxon_x-values4.tsv', 'w') as x_output_file:

        y_values = {}
        next(y_file)
        for line in y_file:
            parts = line.strip().split('\t')
            quadruplet_name = parts[0]
            values_str = parts[1]
            y_values[quadruplet_name] = [float(value) for value in values_str.split(', ')]

        header = sample_file.readline().strip().split('\t')[1:]
        data = [line.strip().split('\t') for line in sample_file]

        x_output_file.write('\t'.join(['Enzyme Quadruplet', 'Sample Name', 'Enzyme Name', 'Values']) + '\n')

        for quadruplet_name, y_positive_values in y_values.items():
            sample_names = quadruplet_name.split('-')
            for sample_name in sample_names:
                sample_row = next(row for row in data if row[0] == sample_name)
                sample_positive_values = [float(value) for value in sample_row[1:] if float(value) > 0]
                unique_values = set(sample_positive_values) - set(y_positive_values)

                if unique_values:
                    for value in unique_values:
                        enzyme_name = header[sample_row[1:].index(str(value)) - 1]
                        x_output_file.write(f'{quadruplet_name}\t{enzyme_name}\t{sample_name}\t{value}\n')

    # Perform Mann-Whitney U test
    with open('pollution_abundance.tsv', 'r') as pollution_file, \
         open('s_Wilcoxon_y-samples4.tsv', 'r') as y_file, \
         open('s_Wilcoxon_x-values4.tsv', 'r') as x_file, \
         open('s_MannU4.tsv', 'w') as mann_u_file:

        next(pollution_file)
        pollution_data = [line.strip().split('\t') for line in pollution_file]

        y_values = {}
        for line in y_file:
            parts = line.strip().split('\t')
            quadruplet_name = parts[0]
            values_str = parts[1]
            sample_values = []
            for sample_name in values_str.split(', '):
                try:
                    value = extract_values(sample_name, pollution_data)
                    sample_values.append(value)
                except ValueError as e:
                    print(f"Warning: {e}. Skipping this sample.")
                    continue
            y_values[quadruplet_name] = sample_values

        x_values = {}
        next(x_file)
        for line in x_file:
            parts = line.strip().split('\t')
            quadruplet_name = parts[0]
            sample_name = parts[1]
            enzyme_name = parts[2]
            try:
                value = extract_values(sample_name, pollution_data)
                key = f'{quadruplet_name} {enzyme_name}'
                if key in x_values:
                    x_values[key].append(value)
                else:
                    x_values[key] = [value]
            except ValueError as e:
                print(f"Warning: {e}. Skipping this sample.")
                continue

        mann_u_file.write('\t'.join(['Enzyme Quadruplet', 'Enzyme Name', 'Mann U']) + '\n')
        for key, x_sample_values in x_values.items():
            quadruplet_name, enzyme_name_x = key.split()
            y_sample_values = y_values.get(quadruplet_name, [])
            if len(x_sample_values) >= 2 and len(y_sample_values) >= 2:
                stat, p_value = mannwhitneyu(x_sample_values, y_sample_values, alternative='two-sided')
                mann_u_file.write(f'{quadruplet_name}\t{enzyme_name_x}\t{p_value}\n')
            else:
                print(f"Warning: Not enough samples for {quadruplet_name} {enzyme_name_x}. Skipping Mann-Whitney U test.")

    # Filter significant combinations
    m_value = 0.1
    with open('s_MannU4.tsv', 'r') as mann_u_file, \
         open('s_sig_combo4.tsv', 'w') as output_file:

        output_file.write('\t'.join(['Enzyme Quadruplet', 'Enzyme Name', 'Mann U']) + '\n')
        next(mann_u_file)
        for line in mann_u_file:
            values = line.strip().split('\t')
            enzyme_quadruplet = values[0]
            enzyme_name = values[1]
            mann_u_value = float(values[2])
            if mann_u_value < m_value:
                next_values = next(mann_u_file, None)
                if next_values is not None:
                    next_values = next_values.strip().split('\t')
                    next_enzyme_name = next_values[1]
                    next_mann_u_value = float(next_values[2])
                    if next_mann_u_value < m_value:
                        output_file.write('\t'.join([enzyme_quadruplet, enzyme_name, str(mann_u_value)]) + '\n')
                        output_file.write('\t'.join([enzyme_quadruplet, next_enzyme_name, str(next_mann_u_value)]) + '\n')

if __name__ == "__main__":
    main()





from scipy.stats import binom, mannwhitneyu
from itertools import combinations

def calculate_binomial_distribution(k, n, p):
    return binom.pmf(k, n, p)

def extract_values(sample_name, pollution_data):
    for row in pollution_data:
        if row[0] == sample_name:
            return float(row[1])
    raise ValueError(f"Sample '{sample_name}' not found in pollution data.")

def process_combinations(combination_size, input_file, enzyme_percentages, sample_names, lines, n):
    output_file_name = f's_combo{combination_size}.tsv'
    y_file_name = f's_Wilcoxon_y-values{combination_size}.tsv'
    samples_file_name = f's_Wilcoxon_y-samples{combination_size}.tsv'

    with open(output_file_name, 'w') as output_file, \
         open(y_file_name, 'w') as y_file, \
         open(samples_file_name, 'w') as samples_file:

        output_file.write('\t'.join([f'Enzyme{i+1}' for i in range(combination_size)] + ['Count Percentage', 'Matches', 'Binomial Distribution', 'p_value']) + '\n')
        y_file.write('\t'.join([f'Enzyme {"-".join([f"Enzyme{i+1}" for i in range(combination_size)])}', 'Values']) + '\n')

        for combo in combinations(range(len(lines)), combination_size):
            count_matches = 0
            positive_values = []

            for m in range(1, len(sample_names) + 1):
                values = [float(lines[idx].strip().split('\t')[m]) for idx in combo]
                if all(value > 0 for value in values):
                    count_matches += 1
                    positive_values.append(', '.join(map(str, values)))

            if count_matches >= n:
                samples = [lines[idx].strip().split('\t')[0] for idx in combo]
                percentages = [enzyme_percentages.get(sample, 0) for sample in samples]
                fraction = 1
                for p in percentages:
                    fraction *= p
                distribution = calculate_binomial_distribution(count_matches, 41, fraction)
                p_value = sum(calculate_binomial_distribution(k, 41, fraction) for k in range(count_matches, 42))

                if p_value < 0.01:
                    output_file.write('\t'.join(samples + [str(fraction), str(count_matches), str(distribution), str(p_value)]) + '\n')
                    combo_name = '-'.join(samples)
                    values_str = ', '.join(positive_values)
                    y_file.write(f'{combo_name}\t{values_str}\n')
                    for idx, value in enumerate(positive_values):
                        sample_name = sample_names[idx]
                        values_str = values_str.replace(value, sample_name)
                    samples_file.write(f'{combo_name}\t{values_str}\n')

def main():
    n = 10

    # Read enzyme percentages
    with open('s_sorted_normalized.tsv', 'r') as enzyme_file:
        enzyme_names = enzyme_file.readline().strip().split('\t')[1:]
        enzyme_percentages = {}
        for line in enzyme_file:
            values = line.strip().split('\t')
            enzyme_name = values[0]
            positive_values = sum(1 for value in values[1:] if float(value) > 0)
            enzyme_percentages[enzyme_name] = positive_values / 243

    # Process input file
    with open('s_single.tsv', 'r') as input_file:
        sample_names = input_file.readline().strip().split('\t')[1:]
        lines = input_file.readlines()

    # Process combinations of size 2, 3, and 4
    for combination_size in [2, 3, 4]:
        process_combinations(combination_size, input_file, enzyme_percentages, sample_names, lines, n)

    # Process y-values and x-values for combinations of size 2, 3, and 4
    for combination_size in [2, 3, 4]:
        y_file_name = f's_Wilcoxon_y-values{combination_size}.tsv'
        x_output_file_name = f's_Wilcoxon_x-values{combination_size}.tsv'

        with open(y_file_name, 'r') as y_file, \
             open('s_single.tsv', 'r') as sample_file, \
             open(x_output_file_name, 'w') as x_output_file:

            y_values = {}
            next(y_file)
            for line in y_file:
                parts = line.strip().split('\t')
                combo_name = parts[0]
                values_str = parts[1]
                y_values[combo_name] = [float(value) for value in values_str.split(', ')]

            header = sample_file.readline().strip().split('\t')[1:]
            data = [line.strip().split('\t') for line in sample_file]

            x_output_file.write('\t'.join([f'Enzyme {"-".join([f"Enzyme{i+1}" for i in range(combination_size)])}', 'Sample Name', 'Enzyme Name', 'Values']) + '\n')

            for combo_name, y_positive_values in y_values.items():
                sample_names_combo = combo_name.split('-')
                for sample_name in sample_names_combo:
                    sample_row = next(row for row in data if row[0] == sample_name)
                    sample_positive_values = [float(value) for value in sample_row[1:] if float(value) > 0]
                    unique_values = set(sample_positive_values) - set(y_positive_values)

                    if unique_values:
                        for value in unique_values:
                            enzyme_name = header[sample_row[1:].index(str(value)) - 1]
                            x_output_file.write(f'{combo_name}\t{enzyme_name}\t{sample_name}\t{value}\n')

    # Perform Mann-Whitney U test for combinations of size 2, 3, and 4
    for combination_size in [2, 3, 4]:
        y_file_name = f's_Wilcoxon_y-samples{combination_size}.tsv'
        x_file_name = f's_Wilcoxon_x-values{combination_size}.tsv'
        mann_u_file_name = f's_MannU{combination_size}.tsv'

        with open('pollution_abundance.tsv', 'r') as pollution_file, \
             open(y_file_name, 'r') as y_file, \
             open(x_file_name, 'r') as x_file, \
             open(mann_u_file_name, 'w') as mann_u_file:

            next(pollution_file)
            pollution_data = [line.strip().split('\t') for line in pollution_file]

            y_values = {}
            for line in y_file:
                parts = line.strip().split('\t')
                combo_name = parts[0]
                values_str = parts[1]
                sample_values = []
                for sample_name in values_str.split(', '):
                    try:
                        value = extract_values(sample_name, pollution_data)
                        sample_values.append(value)
                    except ValueError as e:
                        print(f"Warning: {e}. Skipping this sample.")
                        continue
                y_values[combo_name] = sample_values

            x_values = {}
            next(x_file)
            for line in x_file:
                parts = line.strip().split('\t')
                combo_name = parts[0]
                sample_name = parts[1]
                enzyme_name = parts[2]
                try:
                    value = extract_values(sample_name, pollution_data)
                    key = f'{combo_name} {enzyme_name}'
                    if key in x_values:
                        x_values[key].append(value)
                    else:
                        x_values[key] = [value]
                except ValueError as e:
                    print(f"Warning: {e}. Skipping this sample.")
                    continue

            mann_u_file.write('\t'.join([f'Enzyme {"-".join([f"Enzyme{i+1}" for i in range(combination_size)])}', 'Enzyme Name', 'Mann U']) + '\n')
            for key, x_sample_values in x_values.items():
                combo_name, enzyme_name_x = key.split()
                y_sample_values = y_values.get(combo_name, [])
                if len(x_sample_values) >= 2 and len(y_sample_values) >= 2:
                    stat, p_value = mannwhitneyu(x_sample_values, y_sample_values, alternative='two-sided')
                    mann_u_file.write(f'{combo_name}\t{enzyme_name_x}\t{p_value}\n')
                else:
                    print(f"Warning: Not enough samples for {combo_name} {enzyme_name_x}. Skipping Mann-Whitney U test.")

    # Filter significant combinations for size 2, 3, and 4
    m_value = 0.1
    for combination_size in [2, 3, 4]:
        mann_u_file_name = f's_MannU{combination_size}.tsv'
        sig_combo_file_name = f's_sig_combo{combination_size}.tsv'

        with open(mann_u_file_name, 'r') as mann_u_file, \
             open(sig_combo_file_name, 'w') as output_file:

            output_file.write('\t'.join([f'Enzyme1-Enzyme2{"-Enzyme3" if combination_size >= 3 else ""}{"-Enzyme4" if combination_size >= 4 else ""}', 'Enzyme Name', 'Mann U']) + '\n')

            # Read all lines from the Mann-Whitney U file
            mann_u_lines = mann_u_file.readlines()[1:]  # Skip header
            mann_u_data = [line.strip().split('\t') for line in mann_u_lines]

            # Group p-values by enzyme combination
            combo_dict = {}
            for line in mann_u_data:
                combo_name = line[0]
                enzyme_name = line[1]
                mann_u_value = float(line[2])
                if combo_name not in combo_dict:
                    combo_dict[combo_name] = []
                combo_dict[combo_name].append((enzyme_name, mann_u_value))

            # Write all enzymes in the combination if any meet the threshold
            for combo_name, enzymes in combo_dict.items():
                # Check if any enzyme in the combination meets the threshold
                if any(mann_u_value < m_value for _, mann_u_value in enzymes):
                    for enzyme_name, mann_u_value in enzymes:
                        if mann_u_value < m_value:
                            output_file.write(f'{combo_name}\t{enzyme_name}\t{mann_u_value}\n')

if __name__ == "__main__":
    main()